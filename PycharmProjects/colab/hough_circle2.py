# -*- coding: utf-8 -*-
"""hough_circle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/186Suz1gL-69QECC1TeOGb2wdlsi3RcW2
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np
import cv2
from collections import defaultdict
from math import cos, sin, pi

image = cv2.imread('coins.png')
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
height, width = gray.shape
print(height, width)

plt.imshow(gray, cmap='gray')
plt.show()

img_sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)
img_sobel_x = cv2.convertScaleAbs(img_sobel_x)

img_sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)
img_sobel_y = cv2.convertScaleAbs(img_sobel_y)


img_sobel = cv2.addWeighted(img_sobel_x, 1, img_sobel_y, 1, 0);

plt.figure(figsize=(14,7))
plt.subplot(131)
plt.imshow(img_sobel_x, cmap='gray')

plt.subplot(132)
plt.imshow(img_sobel_y, cmap='gray')

plt.subplot(133)
plt.imshow(img_sobel, cmap='gray')

plt.show()

threshold, binary_img = cv2.threshold(img_sobel, 245, 255, cv2.THRESH_BINARY)

print(threshold)
plt.imshow(binary_img, cmap='gray')
plt.show()

"""아래 함수를 작성할 시 opencv 라이브러리를 사용하지 말고 모든 내용을 직접 작성하시기 바람"""

def Hough_Circles(binary_img, r_min, r_max):
  w, h = binary_img.shape

  max_len = int(round(np.sqrt(w ** 2 + h ** 2)))
  thetas = np.deg2rad(np.linspace(0, 360, 100))
  rhos = np.linspace(0, max_len, 100)
  radius = np.arange(r_min, r_max)

  cos_t = np.cos(thetas)
  sin_t = np.sin(thetas)
  n_thetas = len(thetas)
  n_radius = len(radius)

  accumulator = np.zeros((w, h, n_radius), dtype=np.int16)
  y_idxs, x_idxs = np.nonzero(binary_img > 0)

  for i in range(len(x_idxs)):
    x = x_idxs[i]
    y = y_idxs[i]
    for t_idx in range(n_thetas):
      for rho in rhos:
        a = int(round(x - rho * cos_t[t_idx]))
        b = int(round(y - rho * sin_t[t_idx]))
        r = int(round(np.sqrt((a - x) ** 2 + (b - y) ** 2)))
        if a < 0 or a >= w or b < 0 or b >= h or r >= r_max or r < r_min:
          continue
        accumulator[a, b, r - r_min] += 1

  return accumulator

def draw_circle(shape, center, r):
  img = np.zeros(shape)
  theta = np.linspace(0, 2 * np.pi, 360)
  a, b = center
  for t in theta:
    x = int(round(a + r * np.cos(t)))
    y = int(round(b + r * np.sin(t)))
    img[x, y] = 255
  return img

def display_Circles(circles_list, image):
  print(circles_list)
  for circle in circles_list:
    cv2.circle(image, (circle[1], circle[0]), circle[2], (255, 0, 0), 2)

  cv2.imshow('image', image)
  cv2.waitKey()

def hough(img, rmin, rmax, minH):

  # deep copy - we make new picture and we draw circles on it
  imgnew = cv2.imread(path)

  """Parameters:"""
  # min radius and max radius of circles we are looking for
  rmin = 80
  rmax = 90

  # minimum threshold of voting to be considerated as center of circle with radius r
  minH = 230
  # 220 avg

  # creating the sin and cos of 360:
  sinang = dict()
  cosang = dict()
  for angle in range(0, 360):
    sinang[angle] = np.sin(angle * np.pi / 180)
    cosang[angle] = np.cos(angle * np.pi / 180)

  H = np.zeros((img.shape[0], img.shape[1], (rmax + 1)), dtype=np.uint32)

  # voting function
  for x in range(0, img.shape[0]):
    print("row: " + str(x))  # THIS IS ROW CHECKER SO WE KNOW IT DID NOT GET BUGED
    for y in range(0, img.shape[1]):
      if img[x, y] == 255:
        for r in range(rmin, rmax):
          for angle in range(0, 360):
            b = y - round(r * sinang[angle])
            a = x - round(r * cosang[angle])
            if a >= 0 and a < img.shape[0] and b >= 0 and b < img.shape[1]:
              H[a, b, r] = H[a, b, r] + 1

  """CIRCLE DRAWING"""
  max = 0
  a1 = 0
  b1 = 0

  for r in range(rmin, rmax):
    for a in range(0, img.shape[0]):
      for b in range(0, img.shape[1]):
        if H[a, b, r] > minH:
          # we look for local maximum in matrix of 4x3
          # this part could be better if you also look for loxal maximum in 3D, but this one also gives good results
          max = H[a, b, r]  # A,B
          H[a, b, r] = 0
          a1 = a
          b1 = b
          if a + 2 <= img.shape[0]:
            if b + 2 <= img.shape[1]:
              if H[a + 1, b - 1, r] > max:  # A+1, B-1
                max = H[a + 1, b - 1, r]
                a1 = a + 1
                b1 = b - 1
              H[a + 1, b - 1, r] = 0
              if H[a + 2, b - 1, r] > max:  # A+2, B-1
                max = H[a + 2, b - 1, r]
                a1 = a + 2
                b1 = b - 1
              H[a + 2, b - 1, r] = 0

              for k in range(0, 2):
                for l in range(0, 2):
                  if H[a + k, b + l, r] >= max:
                    max = H[a + k, b + l, r]
                    a1 = a + k
                    b1 = b + l
                  H[a + k, b + l, r] = 0
          # DRAWING OF CIRCLE WITH A1 B1 AS CENTER PARAMETERS
          cv2.circle(imgnew, (b1, a1), r, color=(0, 0, 255), thickness=1, lineType=8, shift=0)

  # END OF FUNCTION- SAVING AN IMAGE
  return imgnew

"""주어진 동전을 읽고 결과를 출력하시오"""

#
# circles = Hough_Circles(binary_img, 80, 90)
# display_Circles(circles, image)
# hough_circle = Hough_Circles(binary_img, 80, 90)
# x, y, r = np.unravel_index(np.argmax(hough_circle), hough_circle.shape)
# circle = draw_circle(image.shape, (x, y), r+80)
#
# hough = np.zeros(image.shape)
# plt.imshow(circle)
# plt.show()

path = 'IMG_NAME.jpg'
bl = 0
IMG_HOUGH = hough(binary_img, path, bl)
cv2.imshow('naslov', IMG_HOUGH)
cv2.waitKey(0)
cv2.destroyAllWindows()
print (IMG_HOUGH.shape)